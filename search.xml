<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>树的直径-题解</title>
      <link href="/posts/1138517949/"/>
      <url>/posts/1138517949/</url>
      
        <content type="html"><![CDATA[<p>都是水题啦，你们都能一眼秒的</p><a id="more"></a><h2 id="BZOJ1999-Noip2007-Core树网的核"><a href="#BZOJ1999-Noip2007-Core树网的核" class="headerlink" title="BZOJ1999 [Noip2007] Core树网的核"></a>BZOJ1999 [Noip2007] Core树网的核</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定一棵带边权无根树，在其直径上求出一段长度不超过 $s$ 的路径 $F$ ，使得离路径距离最远的点到路径的距离 $ECC$ 最短。</p><p>点 $v$ 到路径 $F$ 距离 $D(v,𝐹)$ $=$ $min⁡$ { $d(v,u)$ } , $u$ 为路径上的点</p></blockquote><p>$$<br>n \leq 500000,s &lt; 2^{32} ，所有边权&lt;500<br>$$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对距离 $ECC$ 产生贡献的点来自以下几个部分</p><ul><li>直径的端点</li><li>路径上的点到非直径上点的距离</li></ul><p>对于<strong>直径的端点</strong>，我们有个结论，离一个点距离最远的点是直径的一个端点</p><p>因而我们无需考虑直径上除端点外的其它点，</p><p>那么路径 $F$ 尽可能大，才能保证这部分贡献尽可能小</p><p>但这只是一个部分，我们还要考虑<strong>路径上的点到非直径上点的距离</strong>的贡献</p><p>这部分贡献可能会更大，使实际上的距离 $ECC$ 比<strong>直径的端点</strong>影响造成的 $ECC$ 大，</p><p>以至于掩盖住<strong>直径的端点</strong>的贡献，所以我们要取 $max$ 保证符合定义</p><p>求这部分贡献可以对路径上每个点 $dfs$ 解决</p><p>因为<strong>在直径上且在路径外的点</strong>到<strong>非直径点的距离</strong>一定小于等于<strong>直径的端点</strong>的贡献</p><p>没有影响，为了方便，我们对整个直径上的的点 $dfs$，</p><h3 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;(b))?(a):(b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;(b))?(a):(b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch;<span class="keyword">int</span> f=<span class="number">1</span>;ch=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);) x=x*<span class="number">10</span>+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">500005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGEE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt,wei,to;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++tot].nxt=head[x];</span><br><span class="line">    edge[tot].to=y;</span><br><span class="line">    edge[tot].wei=v;</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,s,maxn,maxp,ls;</span><br><span class="line"><span class="keyword">int</span> dep[N],is_d[N],pre[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre[x]=fa;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;maxn)</span><br><span class="line">    &#123;</span><br><span class="line">        maxp=x;</span><br><span class="line">        maxn=dep[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tt=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(tt==fa||is_d[tt]) <span class="keyword">continue</span>;</span><br><span class="line">        dep[tt]=dep[x]+edge[i].wei;</span><br><span class="line">        dfs(tt,x);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x,y,w,ans=INF;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n);read(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        read(x);read(y);read(w);</span><br><span class="line">        add(x,y,w);add(y,x,w);</span><br><span class="line">    &#125;</span><br><span class="line">    maxn=-INF;</span><br><span class="line">    dep[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ls=maxp;</span><br><span class="line">    maxn=-INF;</span><br><span class="line">    dep[ls]=<span class="number">0</span>;</span><br><span class="line">    dfs(ls,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=maxp,j=maxp;i;i=pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(dep[j]-dep[i]&gt;s) j=pre[j];</span><br><span class="line">        ans=min(ans,max(dep[i],maxn-dep[j]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=maxp;i;i=pre[i])</span><br><span class="line">        is_d[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=maxp;i;i=pre[i])</span><br><span class="line">    &#123;</span><br><span class="line">        dep[i]=<span class="number">0</span>;</span><br><span class="line">        dfs(i,pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=max(ans,dep[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="UVA11695-Flight-Planning"><a href="#UVA11695-Flight-Planning" class="headerlink" title="UVA11695  Flight  Planning"></a>UVA11695  Flight  Planning</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给一个 $N$ 个节点边权为 1 的无根树，去掉一条边，新增一条边，求新的树的最长链，问怎么去边和加边，使得最长链的长度最小</p></blockquote><p>$$<br>1 \leq n \leq 2500<br>$$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>我们可以枚举每一条要删去的边</p><p>去掉这条边后，最小的树的直径会出现在以下几种情况中</p><ul><li>子树 $A$ 的直径</li><li>子树 $B$ 的直径</li><li>加边后树的直径</li></ul><p>子树 $A$ ，$B$ 的直径是固定的，所以我们要保证加边后树的直径最小</p><p>所以要在子树中找到一个点使其到该子树其他点的最大距离最小</p><p>很显然，这个点一定是直径的中点，</p><p>子树的这两个点就是要连边的节点</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch;<span class="keyword">int</span> f=<span class="number">1</span>;ch=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);) x=x*<span class="number">10</span>+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGEE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt,from,to;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],tot;</span><br><span class="line"><span class="keyword">int</span> T,n,x,y,addA,addB,p_addA,p_addB,lenA,lenB,delA,delB,ans=INF;</span><br><span class="line"><span class="keyword">int</span> dep[N],pre[N],maxp,maxn=-INF,minn=INF,rbq,ls;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++tot].nxt=head[x];</span><br><span class="line">    edge[tot].from=x;</span><br><span class="line">    edge[tot].to=y;</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">const</span> <span class="keyword">int</span> &amp;del)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre[x]=fa;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;maxn)</span><br><span class="line">    &#123;</span><br><span class="line">        maxp=x;</span><br><span class="line">        maxn=dep[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==del||i==(del+<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> tt=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(tt==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dep[tt]=dep[x]+<span class="number">1</span>;</span><br><span class="line">        dfs(tt,x,del);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> del)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//memset(pre,0,sizeof(pre));</span></span><br><span class="line">    maxp=edge[del].from;</span><br><span class="line">    maxn=-INF;</span><br><span class="line">    minn=INF;</span><br><span class="line">    dep[edge[del].from]=<span class="number">0</span>;</span><br><span class="line">    dfs(edge[del].from,<span class="number">0</span>,del);</span><br><span class="line"></span><br><span class="line"><span class="comment">//memset(pre,0,sizeof(pre));</span></span><br><span class="line">    ls=maxp;</span><br><span class="line">    maxn=-INF;</span><br><span class="line">    minn=INF;</span><br><span class="line">    dep[ls]=<span class="number">0</span>;</span><br><span class="line">    dfs(ls,<span class="number">0</span>,del);</span><br><span class="line"></span><br><span class="line">    lenA=maxn;</span><br><span class="line">    p_addA=maxp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenA/<span class="number">2</span>;i++) p_addA=pre[p_addA];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//--------------------------------------------------</span></span><br><span class="line"><span class="comment">//memset(pre,0,sizeof(pre));</span></span><br><span class="line">    maxp=edge[del].to;</span><br><span class="line">    maxn=-INF;</span><br><span class="line">    minn=INF;</span><br><span class="line">    dep[edge[del].to]=<span class="number">0</span>;</span><br><span class="line">    dfs(edge[del].to,<span class="number">0</span>,del);</span><br><span class="line"></span><br><span class="line"><span class="comment">//memset(pre,0,sizeof(pre));</span></span><br><span class="line">    ls=maxp;</span><br><span class="line">    maxn=-INF;</span><br><span class="line">    minn=INF;</span><br><span class="line">    dep[ls]=<span class="number">0</span>;</span><br><span class="line">    dfs(ls,<span class="number">0</span>,del);</span><br><span class="line"></span><br><span class="line">    lenB=maxn;</span><br><span class="line">    p_addB=maxp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenB/<span class="number">2</span>;i++) p_addB=pre[p_addB];</span><br><span class="line"></span><br><span class="line">    rbq=max(max(lenA,lenB),(lenA+<span class="number">1</span>)/<span class="number">2</span>+(lenB+<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//    cout&lt;&lt;"$"&lt;&lt;lenA&lt;&lt;' '&lt;&lt;lenB&lt;&lt;"$"&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(ans&gt;rbq)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=rbq;</span><br><span class="line">        delA=edge[del].from;</span><br><span class="line">        delB=edge[del].to;</span><br><span class="line">        addA=p_addA;</span><br><span class="line">        addB=p_addB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">for</span>(;T--;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge));</span><br><span class="line">        tot=<span class="number">0</span>;ans=INF;</span><br><span class="line">        read(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            read(x);read(y);</span><br><span class="line">            add(x,y);add(y,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            solve(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,delA,delB);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,addA,addB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="BZOJ1912-APIO2010-patrol-巡逻"><a href="#BZOJ1912-APIO2010-patrol-巡逻" class="headerlink" title="BZOJ1912  [APIO2010] patrol 巡逻"></a>BZOJ1912  [APIO2010] patrol 巡逻</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p><a href="https://www.luogu.org/problemnew/show/P3629" target="_blank" rel="noopener">链接</a></p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>很显然，当 $k = 1$ 时，找到直径然后连端点就可以了</p><p>当 $k = 2$ 时，我们要找直径和<strong>边不相交</strong>的第二大直径</p><p>当两条直径相交的时候，</p><p>因为加的边必须走，所以第二条加边并没有起到缩短路程的作用，反而多花费了 $1$</p><p>反而不如把边退化成点，长度为 $0$</p><p>找次大直径可以把直径上的边权改成 $-1$ ，再求直径</p><p>由于出现了负边权，用 dfs/bfs 会挂 （可能是我太菜了）</p><p>所以用 $dp$ 求解</p><h3 id="code-2"><a href="#code-2" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">char</span> ch;<span class="keyword">int</span> f=<span class="number">1</span>;ch=getchar();</span><br><span class="line">    <span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(ch);) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">for</span>(;<span class="built_in">isdigit</span>(ch);) x=x*<span class="number">10</span>+(ch^<span class="number">48</span>),ch=getchar();</span><br><span class="line">    x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGEE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt,wei,to;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],tot;</span><br><span class="line"><span class="keyword">int</span> n,k,maxn=-INF,maxp,ls,len1,len2; </span><br><span class="line"><span class="keyword">int</span> dep[N],pre[N],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++tot].nxt=head[x];</span><br><span class="line">    edge[tot].to=y;</span><br><span class="line">    edge[tot].wei=<span class="number">1</span>;</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pre[x]=fa;</span><br><span class="line">    <span class="keyword">if</span>(maxn&lt;dep[x])</span><br><span class="line">    &#123;</span><br><span class="line">        maxn=dep[x];</span><br><span class="line">        maxp=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tt=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(tt==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;' '&lt;&lt;tt&lt;&lt;endl;</span></span><br><span class="line">        dep[tt]=dep[x]+edge[i].wei;</span><br><span class="line">        dfs(tt,x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxlen</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tt=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(tt==fa) <span class="keyword">continue</span>;</span><br><span class="line">        maxlen(tt,x);</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;' '&lt;&lt;tt&lt;&lt;endl;</span></span><br><span class="line">        len2=max(len2,dis[x]+dis[tt]+edge[i].wei);</span><br><span class="line">        dis[x]=max(dis[x],dis[tt]+edge[i].wei);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tt=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(tt==fa||tt!=pre[x]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;' '&lt;&lt;tt&lt;&lt;endl;</span></span><br><span class="line">        edge[i].wei=<span class="number">-1</span>;</span><br><span class="line">        edge[i&amp;<span class="number">1</span>?(i+<span class="number">1</span>):(i<span class="number">-1</span>)].wei=<span class="number">-1</span>;</span><br><span class="line">        work(tt,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n);read(k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        read(x);read(y);</span><br><span class="line">        add(x,y);add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    maxn=-INF;</span><br><span class="line">    dep[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ls=maxp;</span><br><span class="line">    maxn=-INF;</span><br><span class="line">    dep[ls]=<span class="number">0</span>;</span><br><span class="line">    dfs(ls,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    len1=maxn;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">2</span>*(n<span class="number">-1</span>)-len1+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    work(maxp,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    maxlen(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">2</span>*(n<span class="number">-1</span>)-len1-len2+<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树上差分-题解</title>
      <link href="/posts/2952530072/"/>
      <url>/posts/2952530072/</url>
      
        <content type="html"><![CDATA[<p>都是水题啦，你们都能一眼秒的</p><a id="more"></a><h2 id="EOJ-Monthly-2018-8-D-Delivery（水题）"><a href="#EOJ-Monthly-2018-8-D-Delivery（水题）" class="headerlink" title="EOJ Monthly 2018.8 D.Delivery（水题）"></a>EOJ Monthly 2018.8 D.Delivery（水题）</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>有一棵 $N$ 个节点的树 ，树的每条边都有各自的权值 $W_i$ ，在询问开始前，可以交换任一两条边的权值，次数不限，有 $q$ 个询问，每个询问包含一个起点 $S_i$ 和终点 $T_i$ ，从起点到终点经过的边的权值和就是这次询问的花费，求所有询问的最小花费和</p></blockquote><p>$$<br>1 \leq n \leq 2 \times 10^5,1 \leq q \leq 2 \times 10^5<br>$$<br>$$<br>1 \leq u_i,v_i \leq n,u_i \neq v_i<br>$$<br>$$<br>1 \leq w_i \leq 1000<br>$$<br>$$<br>1 \leq s_i,t_i \leq n,s_i \neq t_i<br>$$</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这就是求边覆盖次数的裸题啊，覆盖边按覆盖次数给予从小到大的权值就结束啦</p><p>太水不贴代码</p><hr><h2 id="BZOJ4424-CF19E-Fairy（大水题）"><a href="#BZOJ4424-CF19E-Fairy（大水题）" class="headerlink" title="BZOJ4424/CF19E    Fairy（大水题）"></a>BZOJ4424/CF19E    Fairy（大水题）</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>   给定 $N$ 个点，$M$ 条边的无向图，可以从图中删除一条边，问删除哪些边可以使图变成一个二分图。</p></blockquote><p>$$<br>1 \leq n,m \leq 1000000<br>$$</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先二分图是没有奇环的，我们要删边来去掉奇环</p><p>只有一条边被所有的奇环覆盖时才能去删它，这样才能保证没有奇环</p><p>如果这条边被偶环覆盖的话，无论怎么删都会出现一个新奇环，这条边是不能删的</p><p>我们对图 $dfs$ 遍历，对边新建出一棵树</p><p>然后这个边的覆盖问题就可以通过树上差分解决</p><h3 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt,to,id;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGEE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt,to;</span><br><span class="line">&#125;edge2[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n,m,tot=<span class="number">0</span>,tot2=<span class="number">0</span>,top=<span class="number">0</span>,cnt=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> head[N],head2[N],sta[N&lt;&lt;<span class="number">1</span>],pos[N&lt;&lt;<span class="number">1</span>],vis[N&lt;&lt;<span class="number">1</span>],vis2[N&lt;&lt;<span class="number">1</span>],sum[N&lt;&lt;<span class="number">1</span>],fir[N&lt;&lt;<span class="number">1</span>],ans[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++tot].nxt=head[x];</span><br><span class="line">    edge[tot].to=y;</span><br><span class="line">    edge[tot].id=i;</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge2[++tot2].nxt=head2[x];</span><br><span class="line">    edge2[tot2].to=y;</span><br><span class="line">    head2[x]=tot2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa,<span class="keyword">int</span> pre_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sta[++top]=now;pos[now]=top;vis[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tt=edge[i].to,nid=edge[i].id;</span><br><span class="line">        <span class="keyword">if</span>(nid==pre_id) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!vis2[nid]) vis2[nid]=<span class="number">1</span>,add2(pre_id,nid),add2(nid,pre_id);</span><br><span class="line">        <span class="keyword">if</span>(!pos[tt]) fir[tt]=nid,dfs(tt,now,nid);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[tt])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((pos[now]-pos[tt]+<span class="number">1</span>)&amp;<span class="number">1</span>) sum[nid]++,sum[fir[tt]]--,cnt++;</span><br><span class="line">            <span class="keyword">else</span> sum[nid]--,sum[fir[tt]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[now]=<span class="number">0</span>;top--;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head2[now];i;i=edge2[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tt=edge2[i].to;</span><br><span class="line">        <span class="keyword">if</span>(tt==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(tt,now);</span><br><span class="line">        sum[now]+=sum[tt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum[now]==cnt) ans[++cnt2]=now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> ROY1994</span></span><br><span class="line">        freopen(<span class="string">"testdata.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">        freopen(<span class="string">"A.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    io&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        io&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        add(x,y,i);</span><br><span class="line">        add(y,x,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!pos[i]) dfs(i,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    dfs2(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        io&lt;&lt;m&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            io&lt;&lt;i&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        io&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans+<span class="number">1</span>,ans+cnt2+<span class="number">1</span>);</span><br><span class="line">    io&lt;&lt;cnt2&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt2;i++)</span><br><span class="line">        io&lt;&lt;ans[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    io&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2017-SEERC-L-Divide-and-Conquer（巨水题）"><a href="#2017-SEERC-L-Divide-and-Conquer（巨水题）" class="headerlink" title="2017 SEERC  L.  Divide and Conquer（巨水题）"></a>2017 SEERC  L.  Divide and Conquer（巨水题）</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>有一个有 $N$ 个点的由两棵不同的树构成的复合图(无重边)。</p><p>问最少切断几条边，可以使原图不联通。并输出方案数</p></blockquote><p>$$<br>1 \leq n \leq 1000000<br>$$</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>首先切断的边数肯定是 2 ~ 3 </p><p>这是两棵树组成的图，所以只有 $2N-2$ 条边，</p><p>假设切断 4 条边才能保证不联通，那么至少要有 $2N$ 条边，很显然矛盾</p><p>所以肯定切断 2 ~ 3 条边</p><p>那么必然是一颗树上切断 1 条边，另一颗树上切断 1 ~ 2 条边</p><p>我们先以 $A$ 树为主，把 $B$ 树的边作为返祖边/横插边</p><p>那么就相当于求横跨 $A$ 树的属于 $B$ 树的边数，</p><p>这个可以通过树上差分解决</p><p>每个节点的 $sum$ 就是横跨其的 $B$ 树边数</p><p>我们对 $sum+1$ 取最小值 $minn$ 并记录方案数</p><p>如果 $minn=2$ 直接输出</p><p>如果 $minn=3$ 因为可以 $A$ 树断 2 条， $B$ 树断 1 条</p><p>我们交换再统计一次方案加上之前的就是方案数</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">char</span> ch=getchar();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)w=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) s=s*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to;</span><br><span class="line">&#125;A[N&lt;&lt;<span class="number">1</span>],B[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGEE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt,to;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>,head[N];</span><br><span class="line"><span class="keyword">int</span> f[N][<span class="number">30</span>],dep[N],sum[N],q[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,stp,ans,minn=<span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">int</span> m1,m2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++tot].nxt=head[x];</span><br><span class="line">    edge[tot].to=y;</span><br><span class="line">    head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line">    dep[<span class="number">1</span>]=<span class="number">1</span>;f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    q[++tail]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(Head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now=q[Head++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tt=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dep[tt]) <span class="keyword">continue</span> ;</span><br><span class="line">            dep[tt]=dep[now]+<span class="number">1</span>;</span><br><span class="line">            f[tt][<span class="number">0</span>]=now;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=stp;j++)</span><br><span class="line">                f[tt][j]=f[f[tt][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">            q[++tail]=tt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=stp;i&gt;=<span class="number">0</span>;i--) </span><br><span class="line">        <span class="keyword">if</span>(dep[f[x][i]]&gt;=dep[y]) x=f[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=stp;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tt=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(tt==f[x][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(tt);</span><br><span class="line">        sum[x]+=sum[tt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(sum[x]+<span class="number">1</span>&lt;minn) minn=sum[x]+<span class="number">1</span>,ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum[x]+<span class="number">1</span>==minn) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ADD</span><span class="params">(<span class="keyword">int</span> ff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ff==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            add(A[i].from,A[i].to),add(A[i].to,A[i].from);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            add(B[i].from,B[i].to),add(B[i].to,B[i].from);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ClearE</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge));</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">    <span class="built_in">memset</span>(dep,<span class="number">0</span>,<span class="keyword">sizeof</span>(dep));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen("ME.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("ME.out","w",stdout);</span></span><br><span class="line">    n=read();</span><br><span class="line">    stp=(<span class="keyword">int</span>)log2(n)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x=read();y=read();</span><br><span class="line">        A[i].from=x,A[i].to=y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x=read();y=read();</span><br><span class="line">        B[i].from=x,B[i].to=y;</span><br><span class="line">    &#125;</span><br><span class="line">    ADD(<span class="number">1</span>);</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[B[i].from]++;</span><br><span class="line">        sum[B[i].to]++;</span><br><span class="line">        sum[lca(B[i].from,B[i].to)]-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(minn==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,minn,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ClearE();</span><br><span class="line">    ADD(<span class="number">2</span>);</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[A[i].from]++;</span><br><span class="line">        sum[A[i].to]++;</span><br><span class="line">        sum[lca(A[i].from,A[i].to)]-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,minn,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bitset讲解</title>
      <link href="/posts/36423/"/>
      <url>/posts/36423/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了写一道<a href="https://www.luogu.org/problemnew/show/P3674" target="_blank" rel="noopener">毒瘤题</a>，决定学一下 <strong>bitset</strong></p></blockquote><a id="more"></a><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p> <code>#include&lt;bitset&gt;</code></p><p>  同时需要命名空间 <code>std</code></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span> &lt;N&gt; bs</span><br><span class="line"><span class="comment">// 默认的构造函数将其初始为全0</span></span><br></pre></td></tr></table></figure><p>有一个值得注意的地方，<strong>bitset</strong> 的 $bs[0]$ 是最后一位，而 $bs[N-1]$ 是第一位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bs;</span><br><span class="line"><span class="comment">//bs[0] = 1;            // 0000 0001</span></span><br><span class="line"><span class="comment">//bs[7] = 1;            // 1000 0000</span></span><br></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bs(<span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 0000 0111</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bs(<span class="number">0x07</span>);</span><br><span class="line">    <span class="comment">// 0000 0111</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">short</span>&gt;::digits&gt; bs1(<span class="number">267</span>);</span><br><span class="line">    <span class="comment">// 16位 </span></span><br><span class="line"><span class="built_in">bitset</span>&lt;numeric_limits&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>&gt;::digits&gt; bs2(<span class="number">267</span>);</span><br><span class="line">    <span class="comment">// 32位</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;8&gt; bs(<span class="string">"00000111"</span>);</span><br><span class="line">    <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td><code>bs.any()</code></td><td>是否存在值为 1 的二进制位</td></tr><tr><td><code>bs.none()</code></td><td>是否不存在值为 1 的二进制位  或者说是否全部位为 0</td></tr><tr><td><code>bs.size()</code></td><td>位长，也即是非模板参数值</td></tr><tr><td><code>bs.count()</code></td><td>值为 1 的个数</td></tr><tr><td><code>bs.test(pos)</code></td><td>测试 pos 处的二进制位是否为 1         返回和0做或运算的值</td></tr><tr><td><code>bs.set()</code></td><td>全部位置重置为 1</td></tr><tr><td><code>bs.set(pos)</code></td><td>pos 位的二进制位置与 1 做或运算</td></tr><tr><td><code>bs.reset()</code></td><td>全部位置重置为 0</td></tr><tr><td><code>bs.reset(pos)</code></td><td>pos 位的二进制位置与 0 做或运算</td></tr><tr><td><code>bs.flip()</code></td><td>全部位逐位取反</td></tr><tr><td><code>bs.flip(pos)</code></td><td>pos处的二进制位取反</td></tr><tr><td><code>bs.to_ulong()</code></td><td>将二进制转换为unsigned long输出</td></tr><tr><td><code>bs.to_string()</code></td><td>将二进制转换为字符串输出</td></tr><tr><td><code>~bs</code></td><td>按位取反 效果等效为 <code>bs.flip()</code></td></tr><tr><td><code>os &lt;&lt; b</code></td><td>将二进制位输出到os流 小值在右，大值在左</td></tr></tbody></table><h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><p><strong>bitset</strong> 的运算就像一个普通的整数一样，可以进行 与 ( <strong>&amp;</strong> ) 、或 ( <strong>|</strong> ) 、 异或 ( <strong>^</strong> )、 左移 ( <strong>&lt;&lt;</strong> ) 、 右移 ( <strong>&gt;&gt;</strong> ) 等操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;4&gt; foo (<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"1001"</span>));</span><br><span class="line"><span class="built_in">bitset</span>&lt;4&gt; bar (<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">"0011"</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo^=bar) &lt;&lt; <span class="string">'\n'</span>;       <span class="comment">// 1010 (XOR,assign)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo&amp;=bar) &lt;&lt; <span class="string">'\n'</span>;       <span class="comment">// 0010 (AND,assign)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo|=bar) &lt;&lt; <span class="string">'\n'</span>;       <span class="comment">// 0011 (OR,assign)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo&lt;&lt;=<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>;        <span class="comment">// 1100 (SHL,assign)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo&gt;&gt;=<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;        <span class="comment">// 0110 (SHR,assign)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (~bar) &lt;&lt; <span class="string">'\n'</span>;           <span class="comment">// 1100 (NOT)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (bar&lt;&lt;<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;         <span class="comment">// 0110 (SHL)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (bar&gt;&gt;<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;         <span class="comment">// 0001 (SHR)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo==bar) &lt;&lt; <span class="string">'\n'</span>;       <span class="comment">// false (0110==0011)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo!=bar) &lt;&lt; <span class="string">'\n'</span>;       <span class="comment">// true  (0110!=0011)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo&amp;bar) &lt;&lt; <span class="string">'\n'</span>;        <span class="comment">// 0010</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo|bar) &lt;&lt; <span class="string">'\n'</span>;        <span class="comment">// 0111</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (foo^bar) &lt;&lt; <span class="string">'\n'</span>;        <span class="comment">// 0101</span></span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="http://www.cplusplus.com/reference/bitset/bitset/" target="_blank" rel="noopener">C++ Reference</a></p><p><a href="https://blog.csdn.net/lanchunhui/article/details/49644373" target="_blank" rel="noopener">CSDN by Inside_Zhang</a></p><p><a href="https://www.cnblogs.com/RabbitHu/p/bitset.html" target="_blank" rel="noopener">胡小兔的OI博客</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> stl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数论</title>
      <link href="/posts/15425/"/>
      <url>/posts/15425/</url>
      
        <content type="html"><![CDATA[<blockquote><p>又开了一个丧心病狂的大坑，<del>几个月都打不完</del>，希望noip前可以打的完吧<del>（又是一个flag）</del></p></blockquote><a id="more"></a><h1 id="最大公约数（GCD）"><a href="#最大公约数（GCD）" class="headerlink" title="最大公约数（GCD）"></a>最大公约数（GCD）</h1><p>一般使用<strong>欧几里得算法（辗转相除法）</strong>求最大公约数，但在高精情况下，<strong>%</strong>运算过慢，我们使用<strong>更相损减术</strong>来代替<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//辗转相除法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//更相损减术</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(a!=b)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b) a-=b;</span><br><span class="line">        <span class="keyword">else</span> b-=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小公倍数（LCM）"><a href="#最小公倍数（LCM）" class="headerlink" title="最小公倍数（LCM）"></a>最小公倍数（LCM）</h1><p>求两个数 $x$，$y$ 的最小公倍数，易得 $lcm(x,y)=\frac {x*y}{gcd(x,y)}$</p><h1 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h1><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>没啥好说的。。。时间复杂度 $O(n^2)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(x);i++)</span><br><span class="line">    <span class="keyword">if</span>(x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Eratosthenes筛法（埃氏筛）"><a href="#Eratosthenes筛法（埃氏筛）" class="headerlink" title="Eratosthenes筛法（埃氏筛）"></a>Eratosthenes筛法（埃氏筛）</h2><p>我们倒着来想，因为一个数的倍数不可能是质数，所以我们从 $2$ 开始往上筛，发现一个数没有被标记过，那么这个数肯定就是一个质数，再把它的倍数打个标记，时间复杂度 $O(nloglogn)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求1~n的所有质数</span></span><br><span class="line"><span class="keyword">bool</span> prime[<span class="number">10000000</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">   <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) prime[i]=<span class="number">1</span>;</span><br><span class="line">    prime[<span class="number">1</span>]=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>; i&lt;=n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!prime[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=i*<span class="number">2</span>;j&lt;=n;j+=i) prime[j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Euler筛法（欧拉筛）"><a href="#Euler筛法（欧拉筛）" class="headerlink" title="Euler筛法（欧拉筛）"></a>Euler筛法（欧拉筛）</h2><p>欧拉筛是埃氏筛的优化，在埃氏筛的过程中，我们可以发现有一些数被筛了多次，例如 $6$ ,在 $2$ 和 $3$ 的时候都被筛了一次，假如我们可以避免这些重复，我们就可以做到 $O(n)$ 的时间复杂度，先给出代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求1~n的所有质数</span></span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">10000000</span>+<span class="number">5</span>],ntpri[<span class="number">10000000</span>+<span class="number">5</span>],tot;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ntpri[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(!ntpri[i]) pri[++tot]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;i*pri[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">        ntpri[pri[j]*i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//关键</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这句 <code>if(i%pri[j]==0) break;</code> 是关键所在</p><p>假设我们筛到了第 $i$ 个数，循环到 $prime[j]$ ，</p><p>如果 $prime[j]|i$ ，那么必定有一个数 $x$   ，使得 $i=x \cdot prime[j]$ ，</p><p>那么如果下一个数 $prime[j+1]$ 和 $i$ 相乘，就会得到一个数 $p$ ，</p><p>而 $p=prime[j+1] \cdot i=prime[j+1] \cdot x \cdot prime[j]=k*prime[j]$</p><p>设 $k=prime[j+1] \cdot x$ ，</p><p>即 $prime[j+1] \cdot i=k \cdot prime[j]$</p><p>所以在未来一定有一个数乘以 $prime[j]$ 恰好可以把 $p$ 筛掉，不必要再到 $prime[j+1]$ 筛这个数</p><h2 id="Miller-Rabin算法"><a href="#Miller-Rabin算法" class="headerlink" title="Miller Rabin算法"></a>Miller Rabin算法</h2><p><strong>Miller Rabin</strong> 是依据于费马小定理的一个 <strong>随机算法</strong> ，先介绍费马小定理<br>$$<br>a^{P-1}\equiv 1(modP)<br>$$<br>其中 $P$ 为质数，且 $gcd(a,P)=1$ ，</p><p>假如有一个数 $P$ 对于任何 $a$ 满足该性质，那么 $P$ 是不是就是质数呢？</p><p>然而这是错误的，我们有一个<del>专门针对它</del>的反例： 卡迈克尔数（Carmichael数）</p><blockquote><p>卡迈克尔数的定义是对于合数 $n$，如果对于所有正整数 $b$，$b$ 和 $n$ 互素，</p><p>都有同余式 $b^{N-1}≡ 1 (mod N)$ 成立，则合数 $n$ 为Carmichael数。</p></blockquote><p>但是我们任然可以通过费马小定理来求素数，毕竟100000000以内只有255个卡米切尔数，</p><p>只要我们多次计算，任然可以保证 99.9% 以上的正确率，</p><p><del>但它还是个玄学算法，当然你也可以背下一些int以内所有卡迈克尔数</del> ，</p><p><del>先咕咕咕</del></p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h2><p>举个栗子（来自百度百科）</p><p><img src="https://upload-images.jianshu.io/upload_images/13056869-629066d94eae426c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>设 $A$ 为 $n \times k$ 阶的矩阵 ，$B$ 为 $k \times m$ 阶的矩阵</p><p>则 $C=A \cdot B$ 可以表示为 $C_{i,j}=\sum_{p=1}^{k}A_{i,p} \times B_{p,j}$</p><p><img src="https://upload-images.jianshu.io/upload_images/13056869-889379c6038a93c5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=m;t++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i][t];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=k;t++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;b[i][t];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=m;t++)</span><br><span class="line">c[i][j]+=a[i][t]*b[t][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=k;t++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;c[i][t]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>先讲 <strong>快速幂</strong>，还是利用二进制的思想<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//求x的k次方</span><br><span class="line">typedef long long LL;</span><br><span class="line">LL fastpow(LL x,LL k)</span><br><span class="line">｛</span><br><span class="line">LL ans=1;</span><br><span class="line">    while(k)</span><br><span class="line">    &#123;</span><br><span class="line">    if(k&amp;1) ans*=x;</span><br><span class="line">        x*=x;</span><br><span class="line">        k&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p><p>矩阵快速幂就是把乘换成矩阵乘QWQ<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL M=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    LL matrix[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">&#125;;</span><br><span class="line">data a,eans;</span><br><span class="line">LL n,k;</span><br><span class="line"><span class="function">data <span class="title">mul</span><span class="params">(data a,data b)</span> </span>&#123;</span><br><span class="line">    data ans;</span><br><span class="line">    <span class="built_in">memset</span>(ans.matrix,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans.matrix));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>; t&lt;=n; ++t) &#123;</span><br><span class="line">                ans.matrix[i][k]=ans.matrix[i][k]%M+a.matrix[i][t]*b.matrix[t][k]%M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">data <span class="title">fastpow</span><span class="params">(data a,LL b)</span> </span>&#123;</span><br><span class="line">    data ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">        ans.matrix[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=mul(ans,a);</span><br><span class="line">        a=mul(a,a);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("testdata (1).in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("1.txt","w",stdout);</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; ++k)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a.matrix[i][k];</span><br><span class="line">    </span><br><span class="line">    eans=fastpow(a,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; ++k)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;eans.matrix[i][k]%M&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="矩阵加速"><a href="#矩阵加速" class="headerlink" title="矩阵加速"></a>矩阵加速</h2><pre><code></code></pre><p><del>咕咕咕</del></p><h1 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h1><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><h2 id="EXGCD"><a href="#EXGCD" class="headerlink" title="EXGCD"></a>EXGCD</h2><h2 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h2><h1 id="计算相关"><a href="#计算相关" class="headerlink" title="计算相关"></a>计算相关</h1><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h2 id="BSGS算法"><a href="#BSGS算法" class="headerlink" title="BSGS算法"></a>BSGS算法</h2><h2 id="高精"><a href="#高精" class="headerlink" title="高精"></a>高精</h2><h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><h2 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h2><h1 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h1><h2 id="lucas定理"><a href="#lucas定理" class="headerlink" title="lucas定理"></a>lucas定理</h2><h2 id="Burnside引理"><a href="#Burnside引理" class="headerlink" title="Burnside引理"></a>Burnside引理</h2><h2 id="Polya定理"><a href="#Polya定理" class="headerlink" title="Polya定理"></a>Polya定理</h2><h1 id="群"><a href="#群" class="headerlink" title="群"></a>群</h1><h2 id="置换群及轮换"><a href="#置换群及轮换" class="headerlink" title="置换群及轮换"></a>置换群及轮换</h2><h1 id="反演"><a href="#反演" class="headerlink" title="反演"></a>反演</h1><h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><h2 id="洲阁筛"><a href="#洲阁筛" class="headerlink" title="洲阁筛"></a>洲阁筛</h2><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h2><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Balance Tree(FHQ Treap)</title>
      <link href="/posts/31323/"/>
      <url>/posts/31323/</url>
      
        <content type="html"><![CDATA[<blockquote><p>听说这个平衡树很<del>好写</del>，所以我尝试去学一下这个<del>毒瘤</del>的数据结构</p></blockquote><h1 id="FHQ-Treap简介"><a href="#FHQ-Treap简介" class="headerlink" title="FHQ Treap简介"></a>FHQ Treap简介</h1><p>FHQ Treap只有两种主要的操作</p><ul><li>分离（split） 把一棵树分成两个树</li><li>合并（merge） 把两棵树合成一棵树</li></ul><p>通过 <strong>分离</strong> 和 <strong>合并</strong> 的操作，FHQ Treap可以完成普通平衡树的很多操作</p><ol><li>插入 </li><li>删除</li><li>查询排名为 $i$ 的数</li><li>查询 $wei$ 的排名</li><li>求 $wei$ 的前驱</li><li>求 $wei$ 的后继</li><li>反转区间</li></ol><a id="more"></a><h1 id="树的节点"><a href="#树的节点" class="headerlink" title="树的节点"></a>树的节点</h1><p>FHQ Treap 的节点维护的 普通Treap 维护的大致相同，我们通过一个结构体来保存信息<br>相关含义如下：</p><ul><li><code>size</code> —&gt; 子树（包括自身）的大小</li><li><code>val</code> —&gt; 该节点的值</li><li><code>rnd</code> —&gt; Treap中用于堆的随机值</li><li><code>l</code> <code>r</code> —&gt; 左节点和右节点</li></ul><p>下面给出代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FHQ</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> size,val,rnd;</span><br><span class="line">&#125;tr[N];</span><br></pre></td></tr></table></figure></p><h1 id="操作-1-插入"><a href="#操作-1-插入" class="headerlink" title="操作 1 : 插入"></a>操作 1 : 插入</h1><p>按照普通treap的写法，我们需要新建一个节点，需要调用newnode函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[++tot].size=<span class="number">1</span>;tr[tot].val=v,tr[tot].rnd=rand();</span><br><span class="line">    <span class="keyword">return</span> tot;<span class="comment">//返回新节点的编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以把原来的数按新节点的值分成两份，再依次合并，就完成了插入的过程<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    spilt(root,wei,x,y);</span><br><span class="line">    <span class="comment">//root表示目前总树的根节点</span></span><br><span class="line">    <span class="comment">//把总树分成以x,y为根节点的两棵树</span></span><br><span class="line">    root=merge(merge(x,newnode(wei)),y);</span><br><span class="line">    <span class="comment">//合并所有子树并重置根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="操作-2-：-删除"><a href="#操作-2-：-删除" class="headerlink" title="操作 2 ： 删除"></a>操作 2 ： 删除</h1><p>删除权值为 $wei$ 的点，先把整颗树以 $wei$ 为权值 $split$ 成两棵树 $x$，$y$，再把 $x$ 树按照 $wei-1$ 分成 $p$，$q$。</p><p>这时候值为wei的点一定为 $q$ 的根，那么我们把 $q$ 的两个子儿子 $merge$ 起来（这一步就是去除掉 $wei$ 的影响），再把他们重新 $merge$ 起来得到一个新的树，这颗树就去除掉了 $wei$ 的影响。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> p,<span class="keyword">int</span> q;</span><br><span class="line">    spilt(root,wei,x,y);</span><br><span class="line">    split(x,wei<span class="number">-1</span>,p,q);</span><br><span class="line">    q=merge(tr[q].l,tr[q].r);</span><br><span class="line">    root=merge(merge(p,q),y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="操作-3-：-查询排名为-i-的数"><a href="#操作-3-：-查询排名为-i-的数" class="headerlink" title="操作 3 ： 查询排名为 i 的数"></a>操作 3 ： 查询排名为 i 的数</h1><p>和普通Treap是一样的，</p><p>但注意，<strong>这个函数返回的是 排名为 <em>i</em> 的数 的节点编号k（值为tr[k].val）</strong> 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> rk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rk&lt;=tr[tr[now].l].size) now=tr[now].l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rk==tr[tr[now].l].size+<span class="number">1</span>) <span class="keyword">return</span> now;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                rk-=tr[re[now].l].size+<span class="number">1</span>;</span><br><span class="line">                now=tr[now].r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="操作-4-：-查询-wei-的排名"><a href="#操作-4-：-查询-wei-的排名" class="headerlink" title="操作 4 ： 查询 wei 的排名"></a>操作 4 ： 查询 wei 的排名</h1><p>把总树按 $wei$ 进行 $spilt$ ，得到左部分树的大小即为rank值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRank</span><span class="params">(<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    spilt(root,wei,x,y);</span><br><span class="line">    <span class="keyword">return</span> tr[x].size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="操作-5-：-求-wei-的前驱"><a href="#操作-5-：-求-wei-的前驱" class="headerlink" title="操作 5 ： 求 wei 的前驱"></a>操作 5 ： 求 wei 的前驱</h1><p>把总树按 $wei-1$ 分成两份，<br>所以小于 $wei$ 的节点都在左部分树中，只需要求出左部分树的size所对应的节点的值，<br>就是所求的 $wei$ 的前驱。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    spilt(root,wei<span class="number">-1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> tr[getNum(x,tr[x].size)].val;</span><br><span class="line">    root=merge(x,y);<span class="comment">//回复原状</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="操作-6-：-求-wei-的后继"><a href="#操作-6-：-求-wei-的后继" class="headerlink" title="操作 6 ： 求 wei 的后继"></a>操作 6 ： 求 wei 的后继</h1><p>找后继是相同的，把总树按 $wei$ 为权值调用 $split$，此时右部分树排名第一的数就是后继<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">suc</span><span class="params">(<span class="keyword">int</span> wei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    spilt(root,wei+<span class="number">1</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> tr[getNum(y,<span class="number">1</span>)].val;</span><br><span class="line">    root=merge(x,y);<span class="comment">//回复原状</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="操作-7-：-反转区间"><a href="#操作-7-：-反转区间" class="headerlink" title="操作 7 ： 反转区间"></a>操作 7 ： 反转区间</h1><p><del>先咕着，有空补</del></p><h1 id="核心-1：-merge-操作"><a href="#核心-1：-merge-操作" class="headerlink" title="核心 1： merge 操作"></a>核心 1： merge 操作</h1><p>$merge$ 操作即按照 FHQ Treap 的附加权值<del>玄学</del>维持平衡并进行合并<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//x 恒&lt; y ,所以需要保证顺序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">    update(x),update(y);</span><br><span class="line">    <span class="keyword">if</span>(tr[x].rnd&lt;tr[y].rnd)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[x].r=merge(tr[x].r,y);</span><br><span class="line">        update(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[y].l=merge(x,tr[y].l);</span><br><span class="line">        update(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="核心-2：-spilt-操作"><a href="#核心-2：-spilt-操作" class="headerlink" title="核心 2： spilt 操作"></a>核心 2： spilt 操作</h1><p>$split$ 是把一颗Treap分开两个树的操作。</p><p>有两种分法，一种是按权值分，一种是按$size$（子树大小）分，具体用哪个要看情况。</p><p>按权值分 <strong>注意这时候权值小于等于 k的节点都在左树中，大于 k的都在右树中</strong> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spilt</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> val,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) x=y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(val&lt;=tr[tr[now].l].val)</span><br><span class="line">            y=now,spilt(tr[now].l,val,x,tr[now].l);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x=now,spilt(tr[now].r,val,tr[now].r,y);</span><br><span class="line">        update(now);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按 $size$ 分 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spilt</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> rnk,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) x=y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rnk&lt;=tr[tr[now].l].size)</span><br><span class="line">            y=now,spilt(tr[now].l,rnk,x,tr[now].l);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x=now,spilt(tr[now].r,rnk-tr[tr[now].l].size<span class="number">-1</span>,tr[now].r,y);</span><br><span class="line">        update(now);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 模版 </tag>
            
            <tag> FHQ Treap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>莫队</title>
      <link href="/posts/20389/"/>
      <url>/posts/20389/</url>
      
        <content type="html"><![CDATA[<p>我们使用一道例题来帮助我们理解莫队算法</p><p><a href="https://www.luogu.org/problemnew/show/P1972" target="_blank" rel="noopener">洛谷P1972</a></p><a id="more"></a><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h2><p>HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，<br>他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此，<br>他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？<br>这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你来解决这个问题。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式:"></a>输入输出格式:</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>第一行：一个整数N，表示项链的长度。</p><p>第二行：N 个整数，表示依次表示项链中贝壳的编号（编号为0 到1000000 之间的整数）。</p><p>第三行：一个整数M，表示HH 询问的个数。</p><p>接下来M 行：每行两个整数，L 和R（1 ≤ L ≤ R ≤ N），表示询问的区间。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>M 行，每行一个整数，依次表示询问对应的答案。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1:"></a>输入样例#1:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>想象一下，如果用暴力算法进行求解的话，我们会选择开一个$cnt$数组，遍历区间，累加求解，</p><p>显然，这样的时间复杂度太高，肯定会爆掉，所以我们需要莫队算法</p><hr><p>首先，我们定义两个指针$curl$，$curr$，每次询问我们通过移动这两个指针来框定区间，</p><p><img src="https://upload-images.jianshu.io/upload_images/13056869-cf00293220a16a59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>假设一开始 $curl$ 指向 $4$ ，$curr$ 指向 $6$，</p><p>下一个询问要求区间 $3$ ~ $5$，那么我们 $curl–$ ，顺带插入 $3$ ，$curr–$，顺带删去 $6$，</p><p><strong>注意当前的先后顺序</strong><br>$curl–$ 要求先减后加入，而 $curr–$ 要求先删去再减</p><p>同理，$curl++$ 要求先删去再加，而 $curr++$ 要求先加再加入</p><p>我们可以写出这一部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lsans;<span class="comment">//表示该区间的答案</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;lsans+=(++cnt[a[pos]]==<span class="number">1</span>);&#125;<span class="comment">//加入</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;lsans-=(--cnt[a[pos]]==<span class="number">0</span>);&#125;<span class="comment">//删去</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(curr&lt;rr) add(++curr);<span class="comment">//变化范围</span></span><br><span class="line"><span class="keyword">while</span>(curr&gt;rr) del(curr--);</span><br><span class="line"><span class="keyword">while</span>(curl&gt;ll) add(--curl);</span><br><span class="line"><span class="keyword">while</span>(curl&lt;ll) del(curl++);</span><br></pre></td></tr></table></figure><h1 id="莫队的优化"><a href="#莫队的优化" class="headerlink" title="莫队的优化"></a>莫队的优化</h1><p>我们可以很容易的发现，如果面对特别设计的数据，上面的时间复杂度仍然很高</p><p>举个栗子，有6个询问如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1, 100)  (2, 2)  (3, 99)  (4, 4)  (5, 102)  (6, 7)</span><br></pre></td></tr></table></figure></p><p>我们如果直接按左端点上升排序，</p><p>用上述方法处理时，左端点会移动$6$次，右端点会移动移动$98+97+95+98+95=483$次。</p><p>我们可以先按左端点上升排序，如果左端点所在的块相同，再在块内按右端点上升排序，得到结果就像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(2, 2)  (4, 4)  (6, 7)  (5, 102)  (3, 99)  (1, 100)</span><br></pre></td></tr></table></figure></p><p>左端点移动次数为$2+2+1+2+2=9$次，比原来稍多。右端点移动次数为$2+3+95+3+1=104$，右端点的移动次数大大降低了。</p><h2 id="Code-："><a href="#Code-：" class="headerlink" title="$Code$："></a>$Code$：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ques</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l , r , id ;</span><br><span class="line">&#125;que[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ques &amp;a,<span class="keyword">const</span> ques &amp;b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.l/blo==b.l/blo)?a.r&lt;b.r:a.l&lt;b.l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最终的代码"><a href="#最终的代码" class="headerlink" title="最终的代码"></a>最终的代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sync_with_stdio(false)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">char</span> ch=getchar();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)w=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) s=s*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ques</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l , r , id ;</span><br><span class="line">&#125;que[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n,m, blo,lsans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ques &amp;a,<span class="keyword">const</span> ques &amp;b)</span> </span>&#123;<span class="keyword">return</span> (a.l/blo==b.l/blo)?a.r&lt;b.r:a.l&lt;b.l;&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>],cnt[<span class="number">1000005</span>],ans[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;lsans+=(++cnt[a[pos]]==<span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;lsans-=(--cnt[a[pos]]==<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    m=read();blo=<span class="built_in">sqrt</span>(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        que[i].l=read(),que[i].r=read();</span><br><span class="line">        que[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(que+<span class="number">1</span>,que+m+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> curl=<span class="number">0</span>,curr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ll=que[i].l,rr=que[i].r,idd=que[i].id;</span><br><span class="line">        <span class="keyword">while</span>(curr&lt;rr) add(++curr);</span><br><span class="line">        <span class="keyword">while</span>(curr&gt;rr) del(curr--);</span><br><span class="line">        <span class="keyword">while</span>(curl&gt;ll) add(--curl);</span><br><span class="line">        <span class="keyword">while</span>(curl&lt;ll) del(curl++);</span><br><span class="line">        ans[idd]=lsans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Segment Tree(ZKW)(PART TWO)</title>
      <link href="/posts/30408/"/>
      <url>/posts/30408/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本来想看看网上的讲解的，结果发现都讲得不清楚，还是自己写一个吧</p></blockquote><hr><h1 id="普通线段树与ZKW线段树"><a href="#普通线段树与ZKW线段树" class="headerlink" title="普通线段树与ZKW线段树"></a>普通线段树与ZKW线段树</h1><blockquote><ul><li><strong>普通线段树</strong>通过递归建树，因而其常数相对较大</li><li><strong>普通线段树</strong>代码长，相对较复杂</li><li><strong>ZKW线段树</strong>通过循环建树，相对常数小</li><li><strong>ZKW线段树</strong>代码短，易理解</li></ul></blockquote><a id="more"></a><h1 id="ZKW线段树-·-无差分弱化版"><a href="#ZKW线段树-·-无差分弱化版" class="headerlink" title="ZKW线段树 · 无差分弱化版"></a>ZKW线段树 · 无差分弱化版</h1><p>线段树是一种堆式储存结构，<br>观察其节点编号</p><p><img src="https://upload-images.jianshu.io/upload_images/13056869-91458b9150248d4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>将其转化成二进制</p><p><img src="https://upload-images.jianshu.io/upload_images/13056869-822d1fc74b118836.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>规律是很显然的</p><blockquote><ul><li>一个节点的父节点是这个数左移1，这个位运算就是低位舍弃，所有数字左移一位</li><li>一个节点的子节点是这个数右移1，是左节点，右移1 +1是右节点</li><li>同一层的节点是依次递增的，第$n$层有$2^{n-1}$个节点</li><li>最后一层有多少节点，值域就是多少(这个很重要)</li></ul></blockquote><p>有了这些规律就可以开始着手建树了</p><p>若树的层数为 $m$ ，则最后一层的节点数 $cnt$ 满足 $cnt = 2^{m-1}$</p><p>若数的个数为 $x$ ，则数的个数x满足 $\frac {cnt}{2} &lt; x &lt;= cnt$<br>（大于$x$小于$cnt$的部分无视）</p><p>底层节点序号从 $cnt$ 开始，一直到 $cnt+n-1$ 结束，第 $p$ 个数编号为 $cnt+p-1$</p><p>所以我们需要先算出这个 $cnt$ 的最小值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(cnt=<span class="number">1</span>;cnt&lt;x;cnt&lt;&lt;=<span class="number">1</span>);<span class="comment">//这里没有等号，以保证cnt最小</span></span><br></pre></td></tr></table></figure></p><h2 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,a[<span class="number">10005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;Tree[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(cnt=<span class="number">1</span>;cnt&lt;x;cnt&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt;i&lt;cnt+n;i++) Tree[i].num=read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这仅仅是对叶子节点进行操作，之后，我们要依次更新父节点<br>由于是自下往上更新，所以，我们应当从 $cnt-1$ 开始，一直到 $1$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=cnt<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    Tree[i].num=Tree[i&lt;&lt;<span class="number">1</span>].num+Tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].num;</span><br></pre></td></tr></table></figure></p><p>最后的建树代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(cnt=<span class="number">1</span>;cnt&lt;x;cnt&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt;i&lt;cnt+n;i++) Tree[i].num=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cnt<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--) Tree[i].num=Tree[i&lt;&lt;<span class="number">1</span>].num+Tree[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="单点操作"><a href="#单点操作" class="headerlink" title="单点操作"></a>单点操作</h2><p>直接修改<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree[cnt+x<span class="number">-1</span>].num+=k;</span><br><span class="line">    <span class="keyword">while</span>(x) Tree[x&gt;&gt;=<span class="number">1</span>].num=Tree[x&lt;&lt;<span class="number">1</span>].num+Tree[x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].num;<span class="comment">//更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="单点查询"><a href="#单点查询" class="headerlink" title="单点查询"></a>单点查询</h2><p>直接修改<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">askpot</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Tree[cnt+pos<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="ZKW线段树-·-差分版"><a href="#ZKW线段树-·-差分版" class="headerlink" title="ZKW线段树 · 差分版"></a>ZKW线段树 · 差分版</h1><h2 id="建树-1"><a href="#建树-1" class="headerlink" title="建树"></a>建树</h2><p>我们发现，上面的方法对于区间操作时间复杂度会很高，因此，我们可以使用差分思想来进行优化</p><p>此时，线段树节点存的值是他和父节点的差值<br>我们再来写一下差分版的build<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (cnt = <span class="number">1</span>; cnt &lt; x; cnt &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &lt; cnt + n; i++) Tree[i].num = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Tree[i].num = min(Tree[i &lt;&lt; <span class="number">1</span>].num, Tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">        Tree[i &lt;&lt; <span class="number">1</span>].num -= Tree[i];</span><br><span class="line">        Tree[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].num -= Tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="单点查询-1"><a href="#单点查询-1" class="headerlink" title="单点查询"></a>单点查询</h2><p>由于差分的性质<br>只需依次向上累加就可以求出改点的值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">askpot</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,x=cnt+pos<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) sum+=Tree[x].num,x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">askRange</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 模版 </tag>
            
            <tag> ZKW线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Segment Tree (PART ONE)</title>
      <link href="/posts/7674/"/>
      <url>/posts/7674/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote><p>线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为$O(logn)$。</p></blockquote><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>下面我们从一个经典的例子来了解线段树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从数组arr[<span class="number">0.</span>..n<span class="number">-1</span>]中查找某个数组某个区间内的最小值，</span><br><span class="line">其中数组大小固定，但是数组中的元素的值可以随时更新。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>我们可以用线段树来解决这个问题：预处理耗时$O(n)$，查询、更新操作$O(logn)$，需要额外的空间$O(n)$。根据这个问题我们构造如下的二叉树</p><ul><li>叶子节点是原始组数arr中的元素</li><li>非叶子节点代表它的所有子孙叶子节点所在区间的最小值<br>例如对于数组[2, 5, 1, 4, 9, 3]可以构造如下的二叉树（背景为白色表示叶子节点，非叶子节点的值是其对应数组区间内的最小值，例如根节点表示数组区间arr[0…5]内的最小值是1）：<br><img src="https://images0.cnblogs.com/blog/517264/201312/01204058-426dce8b8a05491b91edeba9ec2e4112.jpg" alt=""></li></ul><p>由于线段树的父节点区间是平均分割到左右子树，因此线段树是完全二叉树，对于包含$n$个叶子节点的完全二叉树，它一定有$n-1$个非叶节点，总共$2n-1$个节点，因此存储线段是需要的空间复杂度是$O(n)$</p><h1 id="创建线段树"><a href="#创建线段树" class="headerlink" title="创建线段树"></a>创建线段树</h1><h2 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h2><p>根据线段树的性质（完全二叉树），只需知道父节点，就可以计算出子节点的序号<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">getLeftNum</span><span class="params">(LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">getRightNum</span><span class="params">(LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="树的存放和节点信息"><a href="#树的存放和节点信息" class="headerlink" title="树的存放和节点信息"></a>树的存放和节点信息</h2><p>首先，我们需要判断我们需要维护的对象，可以是一个<strong>值</strong>，也可以是<strong>颜色</strong>，<strong>状态</strong>等<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;<span class="comment">//可以添加col,status，lztag</span></span><br><span class="line">&#125;Tree[N];</span><br></pre></td></tr></table></figure></p><h2 id="建树操作"><a href="#建树操作" class="headerlink" title="建树操作"></a>建树操作</h2><p>我们使用递归操作来建树</p><blockquote><ul><li>当左端点和右段点相同时，意味着此时的$p$节点是叶子节点</li><li>二分当前区间，递归建树</li></ul></blockquote><p>注意，这里有两个尚未出现的东西，$pushup$函数和$lztag$标记</p><p>$pushup$函数用于从子节点向上依次更新父节点的值<br>而$lztag$是用于区间修改的懒标记</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(LL p,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lztag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;Tree[p]=a[l];<span class="keyword">return</span> ;&#125;</span><br><span class="line">    LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    buildTree(getLeftNum(p),l,mid);</span><br><span class="line">    buildTree(getRightNum(p),mid+<span class="number">1</span>,r);</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pushup-操作"><a href="#pushup-操作" class="headerlink" title="pushup 操作"></a>pushup 操作</h2><p>$pushup$起到更新的作用，对于不同的需求，有不同的$pushup$操作</p><p>对于求和，可以这么写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree[p]=Tree[getLeftNum(p)]+Tree[getRightNum(p)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而对于求 最大值/最小值 ，则可以这么写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put_up</span><span class="params">(LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree[p]=max(Tree[getLeftNum(p)],Tree[getRightNum(p)]);</span><br><span class="line">    <span class="comment">//Tree[p]=min(Tree[getLeftNum(p)],Tree[getRightNum(p)]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h2><p>更新操作可以分为两种</p><ul><li>单点操作</li><li>区间操作</li></ul><h3 id="单点操作（updataPot）"><a href="#单点操作（updataPot）" class="headerlink" title="单点操作（updataPot）"></a>单点操作（updataPot）</h3><p>明确变量名：</p><ol><li>（l ~ r） ——  可支配区间</li><li>（nedChangeL ~ nedChangeR） ——  需操作区间</li><li>mid —— 可支配区间中点</li></ol><p>注 :</p><blockquote><ul><li>当$mid$不小于$nedChangeL$时 代表去 $l$ ~ $mid$ 更新是有意义的，所以，我们选择更新该区间</li><li>$mid$和$nedChangeR$同理</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updataPot</span><span class="params">(LL nedChangeL,LL nedChangeR,LL l,LL r,LL p,LL num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;Tree[p]=num;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nedChangeL&lt;=mid) updata(nedChangeL,nedChangeR,l,mid,getLeftNum(p),num);</span><br><span class="line">    <span class="keyword">if</span>(nedChangeR&gt;mid) updata(nedChangeL,nedChangeR,mid+<span class="number">1</span>,r,getRightNum(p),num);</span><br><span class="line">    put_up(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间操作（updataInterval）"><a href="#区间操作（updataInterval）" class="headerlink" title="区间操作（updataInterval）"></a>区间操作（updataInterval）</h3><p>#区间操作需要引入一个概念 </p><blockquote><p>$lazytag$ :<br>$lazytag$标注的是线段树中每个树的变化量，即 $\Delta$ </p><p>$lazytag$ 操作时正如其名，只对目前状态打上标记，等到更新时，才向下传递<br>因此，引入另一个函数$pushdown$，用于更新其子节点的$lazytag$和本节点的数值</p></blockquote><p>接下来给出$pushdown$的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">updataSum</span><span class="params">(LL p,LL l,LL r,LL num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lztag[p]=lztag[p]+num;</span><br><span class="line">    Tree[p]+=num*(r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put_down</span><span class="params">(LL p,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    updataSum(getLeftNum(p),l,mid,lztag[p]);</span><br><span class="line">    updataSum(getRightNum(p),mid+<span class="number">1</span>,r,lztag[p]);</span><br><span class="line">    lztag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了$pushdown$算法，我们可以完成$updata$操作<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updataInterval</span><span class="params">(LL needChangeL,LL needChangeR,LL l,LL r,LL p,LL num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needChangeL&lt;=l&amp;&amp;r&lt;=needChangeR) &#123;updataSum(p,l,r,num);<span class="keyword">return</span> ;&#125;</span><br><span class="line">    put_down(p,l,r);</span><br><span class="line">    LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(needChangeL&lt;=mid) updata(needChangeL,needChangeR,l,mid,getLeftNum(p),num);</span><br><span class="line">    <span class="keyword">if</span>(needChangeR&gt;mid) updata(needChangeL,needChangeR,mid+<span class="number">1</span>,r,getRightNum(p),num);</span><br><span class="line">    put_up(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="区间求值（query）"><a href="#区间求值（query）" class="headerlink" title="区间求值（query）"></a>区间求值（query）</h2><p>区间求值时，我们进行了询问，而因为$lazytag$的原因，在求值之前，需先进行$pushdown$操作<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getSum</span><span class="params">(LL qx,LL qy,LL l,LL r,LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(qx&lt;=l&amp;&amp;r&lt;=qy)<span class="keyword">return</span> Tree[p];</span><br><span class="line">    LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    put_down(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(qx&lt;=mid)sum+=getSum(qx,qy,l,mid,getLeftNum(p));</span><br><span class="line">    <span class="keyword">if</span>(qy&gt;mid) sum+=getSum(qx,qy,mid+<span class="number">1</span>,r,getRightNum(p));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 模版 </tag>
            
            <tag> 普通线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最小生成树</title>
      <link href="/posts/57313/"/>
      <url>/posts/57313/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="最小生成树有两种算法"><a href="#最小生成树有两种算法" class="headerlink" title="最小生成树有两种算法"></a>最小生成树有两种算法</h1><h2 id="Prim-amp-Kruskal"><a href="#Prim-amp-Kruskal" class="headerlink" title="Prim &amp; Kruskal"></a>Prim &amp; Kruskal</h2></blockquote><a id="more"></a><h3 id="1-Prim"><a href="#1-Prim" class="headerlink" title="1. Prim"></a>1. Prim</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="keyword">int</span> cost[maxn][maxn],minn,n,m,v2[maxn],tot=<span class="number">1</span>,now,ans;</span><br><span class="line"><span class="keyword">bool</span> v1[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">getcost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">            cost[i][j]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w; i&lt;=m; i++) &#123;</span><br><span class="line">           <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">                <span class="keyword">if</span>(cost[u][v]&gt;w) &#123;</span><br><span class="line">                    cost[u][v]=cost[v][u]=w;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;<span class="comment">//初始化cost数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        v2[i]=cost[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    v1[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//找出与1节点相连的边并进行标记</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(tot&lt;n) &#123; <span class="comment">//最小生成树的概念</span></span><br><span class="line">        minn=inf;</span><br><span class="line">        tot++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!v1[i]&amp;&amp;v2[i]&lt;minn) &#123;</span><br><span class="line">                minn=v2[i];</span><br><span class="line">                now=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//找出最小边</span></span><br><span class="line"></span><br><span class="line">        ans+=minn;<span class="comment">//更新答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v2[i]&gt;cost[now][i]&amp;&amp;!v1[i]) &#123;</span><br><span class="line">                v2[i]=cost[now][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v1[now]=<span class="number">1</span>;<span class="comment">//在找出与now节点相连的边并进行标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getcost();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,prim());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//主函数不解释</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Kruskal"><a href="#2-Kruskal" class="headerlink" title="2. Kruskal"></a>2. Kruskal</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) return a&gt;b?a:b </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span><span class="keyword">int</span> pointA,pointB,w;&#125;edge[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">5005</span>],n,m,ans,eu,ev,cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a,Edge b)</span></span>&#123;<span class="keyword">return</span> a.w&lt;b.w;&#125;<span class="comment">//快排的依据</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">findfather</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=father[x]) x=father[x]=father[father[x]];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;<span class="comment">//并查集模板，用while循环比递归版快</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sort(edge+<span class="number">1</span>,edge+m+<span class="number">1</span>,cmp);<span class="comment">//将边的权值排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        eu=findfather(edge[i].pointA), ev=findfather(edge[i].pointB);</span><br><span class="line">        <span class="keyword">if</span>(eu==ev) <span class="keyword">continue</span>;<span class="comment">//若出现环，则continue</span></span><br><span class="line">        ans+=edge[i].w;<span class="comment">//更新答案</span></span><br><span class="line">        father[ev]=eu; cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;<span class="comment">//循环结束条件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) father[i]=i;<span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;edge[i].pointA,&amp;edge[i].pointB,&amp;edge[i].w);</span><br><span class="line">    kruskal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 模版 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>位运算</title>
      <link href="/posts/60366/"/>
      <url>/posts/60366/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13056869-7a547f75361aceca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><h1 id="1-amp"><a href="#1-amp" class="headerlink" title="1.&amp;"></a>1.&amp;</h1><p>如果两个相应的二进制位都为１，则该位的结果值为1；否则为0。</p><blockquote><p>注：下面都用8位的 unsigned char 来做例子。</p></blockquote><h4 id="amp-简单举例："><a href="#amp-简单举例：" class="headerlink" title="&amp;简单举例："></a>&amp;简单举例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">11&amp;3  = 3</span><br><span class="line"></span><br><span class="line">    00001011</span><br><span class="line"></span><br><span class="line">&amp;   00000011</span><br><span class="line"></span><br><span class="line">=   00000011 </span><br><span class="line">=   3</span><br></pre></td></tr></table></figure><h4 id="amp-比较实用的例子："><a href="#amp-比较实用的例子：" class="headerlink" title="&amp;比较实用的例子："></a>&amp;比较实用的例子：</h4><p>我们经常要用的是否被2整除，一般都写成   if(n % 2 == 0)</p><p>可以换成 if((n&amp;1) == 0) </p><h1 id="2"><a href="#2" class="headerlink" title="2.|"></a>2.|</h1><p>如果两个相应的二进制位只要有一个是1，结果就是1；否则为0。</p><h3 id="简单例子："><a href="#简单例子：" class="headerlink" title="| 简单例子："></a>| 简单例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">11 | 3 = 11</span><br><span class="line"></span><br><span class="line">    00001011</span><br><span class="line"></span><br><span class="line">|   00000011</span><br><span class="line"></span><br><span class="line">=   00001011 </span><br><span class="line"></span><br><span class="line">=   11</span><br></pre></td></tr></table></figure><h3 id="比较实用的例子"><a href="#比较实用的例子" class="headerlink" title="| 比较实用的例子"></a>| 比较实用的例子</h3><p>可以用一个unsigned int 来存储多个布尔值。比如一个文件有读权限，写权限，执行权限。看起来要记录3个布尔值。我们可以用一个unsigned int也可以完成任务。</p><p>一个数r来表示读权限，它只更改个位来记录读权限的布尔值 </p><p>00000001  (表示有读权限) </p><p>00000000  (表示没有读权限)</p><p>一个数w表示写权限，它只用二进制的倒数第二位来记录布尔值</p><p>00000010 (表示有写权限)</p><p>00000000 (表示没有写权限)</p><p>一个数x表示执行权限，它只用倒数第三位来记录布尔值</p><p>00000100 (表示有执行权限)</p><p>00000000 (表示没有执行权限)</p><p>那么一个文件同时没有3种权限就是</p><p>~r | ~ w | ~ x 即为 00000000，就是0</p><p>只有读的权限就是</p><p>r | ~w | ~x 即为 00000001，就是1</p><p>只有写的权限就是</p><p>~r | w | ~x 即为 00000010，就是2</p><p>一个文件同时有3种权限就是</p><p>r | w | x 即为 00000111，就是7</p><h1 id="3-lt-lt-向左移位移"><a href="#3-lt-lt-向左移位移" class="headerlink" title="3. &lt;&lt; 向左移位移"></a>3. &lt;&lt; 向左移位移</h1><h3 id="lt-lt-简单例子-向左移一位，右边自动补0"><a href="#lt-lt-简单例子-向左移一位，右边自动补0" class="headerlink" title="&lt;&lt;简单例子(向左移一位，右边自动补0)"></a>&lt;&lt;简单例子(向左移一位，右边自动补0)</h3><p>11 &lt;&lt; 1 = 22</p><p> 00001011 &lt;&lt; 1</p><p> 00010110 = 22</p><p>相当于二进制的每个数都变成当前值的两倍，结果就是变成当前值的两倍。</p><p>n * 2 == (n &lt;&lt; 1)</p><h1 id="4-gt-gt-向右位移"><a href="#4-gt-gt-向右位移" class="headerlink" title="4. &gt;&gt; 向右位移"></a>4. &gt;&gt; 向右位移</h1><h3 id="gt-gt-简单例子-向右移一位，左边自动补1"><a href="#gt-gt-简单例子-向右移一位，左边自动补1" class="headerlink" title="&gt;&gt;简单例子(向右移一位，左边自动补1)"></a>&gt;&gt;简单例子(向右移一位，左边自动补1)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">11 &gt;&gt; 1 =  5</span><br><span class="line"></span><br><span class="line">00001011 &gt;&gt; 1</span><br><span class="line"></span><br><span class="line">00000101 = 5</span><br></pre></td></tr></table></figure><p>注意到最后一位的1被干掉了。</p><p>比较实用的例子是:</p><p>int n = n / 2     等价于   int n = n &gt;&gt; 1  等价于 int n &gt;&gt;= 1</p><h1 id="5-异或"><a href="#5-异或" class="headerlink" title="5. ^ 异或"></a>5. ^ 异或</h1><p>两个相同的数会变成0，反之是1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">11^3 = 8</span><br><span class="line"></span><br><span class="line">    00001011</span><br><span class="line"></span><br><span class="line">^   00000011</span><br><span class="line"></span><br><span class="line">=   00001000 = 8</span><br></pre></td></tr></table></figure></p><p>Given an array of integers, every element appearstwice except for one. Fnd that single one.</p><p>在一个数组中，所有数字都出现了两次，只有一个没有</p><p>异或是嫉妒成双成对的。</p><p>比如 int t = {1,2,3,3,2,1,5} 要找到5。</p><p>用异或就完美了，所有相同的都会消失，留下来的就是5了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">intsingleNumber(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;  </span><br><span class="line">        A[<span class="number">0</span>] ^= A[i];  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有就是用不tmp值来交换两个数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不用temp交换两个整数</span></span><br><span class="line">voidswap(<span class="keyword">int</span>&amp; x , <span class="keyword">int</span>&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">    x ^= y;</span><br><span class="line">    y ^= x;</span><br><span class="line">    x ^= y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="6"><a href="#6" class="headerlink" title="6.~"></a>6.~</h1><p>这个在加法中用到</p><p>x-y = x + ~y + 1</p><p>所以~y = - y  -1</p><p>比如 ~11 = -11 -1 = -12</p><h1 id="7-快速取模"><a href="#7-快速取模" class="headerlink" title="7.%(快速取模)"></a>7.%(快速取模)</h1><p>求 100 % 8的 优化解法。</p><p>我们知道8刚好是2的3次方，</p><p>所以 100 % 8 == 100 - math.floor(100 / 8) * 8 == 100 -  ((100 &gt;&gt; 3) &lt;&lt; 3)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 模版 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Algorithm&amp;Template</title>
      <link href="/posts/63125/"/>
      <url>/posts/63125/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="/2018/07/24/最小生成树/">最小生成树</a></li><li><a href="/2018/07/26/Segment-Tree-PART-ONE/">普通线段树</a></li><li><a href="/2018/07/27/Segment-Tree-ZKW-PART-TWO/">zkw线段树</a></li><li><a href="/2018/07/29/莫队/">莫队</a></li><li><a href="/404">KMP字符串匹配</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 归档 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
