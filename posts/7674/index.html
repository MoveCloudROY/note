<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Segment Tree (PART ONE) | ROY1994</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Segment Tree (PART ONE)</h1><a id="logo" href="/.">ROY1994</a><p class="description">最菜的OIer</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Segment Tree (PART ONE)</h1><div class="post-meta">Jul 26, 2018</div><a class="disqus-comment-count" href="/posts/7674/#vcomment"><span class="valine-comment-count" data-xid="/posts/7674/"></span><span> 条评论</span></a><div class="post-content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><blockquote>
<p>线段树，类似区间树，它在各个节点保存一条线段（数组中的一段子数组），主要用于高效解决连续区间的动态查询问题，由于二叉结构的特性，它基本能保持每个操作的复杂度为$O(logn)$。</p>
</blockquote>
<a id="more"></a>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>下面我们从一个经典的例子来了解线段树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从数组arr[<span class="number">0.</span>..n<span class="number">-1</span>]中查找某个数组某个区间内的最小值，</span><br><span class="line">其中数组大小固定，但是数组中的元素的值可以随时更新。</span><br></pre></td></tr></table></figure></p>
<p>我们可以用线段树来解决这个问题：预处理耗时$O(n)$，查询、更新操作$O(logn)$，需要额外的空间$O(n)$。根据这个问题我们构造如下的二叉树</p>
<ul>
<li>叶子节点是原始组数arr中的元素</li>
<li>非叶子节点代表它的所有子孙叶子节点所在区间的最小值<br>例如对于数组[2, 5, 1, 4, 9, 3]可以构造如下的二叉树（背景为白色表示叶子节点，非叶子节点的值是其对应数组区间内的最小值，例如根节点表示数组区间arr[0…5]内的最小值是1）：<br><img src="https://images0.cnblogs.com/blog/517264/201312/01204058-426dce8b8a05491b91edeba9ec2e4112.jpg" alt=""></li>
</ul>
<p>由于线段树的父节点区间是平均分割到左右子树，因此线段树是完全二叉树，对于包含$n$个叶子节点的完全二叉树，它一定有$n-1$个非叶节点，总共$2n-1$个节点，因此存储线段是需要的空间复杂度是$O(n)$</p>
<h1 id="创建线段树"><a href="#创建线段树" class="headerlink" title="创建线段树"></a>创建线段树</h1><h2 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h2><p>根据线段树的性质（完全二叉树），只需知道父节点，就可以计算出子节点的序号<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">getLeftNum</span><span class="params">(LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">getRightNum</span><span class="params">(LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="树的存放和节点信息"><a href="#树的存放和节点信息" class="headerlink" title="树的存放和节点信息"></a>树的存放和节点信息</h2><p>首先，我们需要判断我们需要维护的对象，可以是一个<strong>值</strong>，也可以是<strong>颜色</strong>，<strong>状态</strong>等<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;<span class="comment">//可以添加col,status，lztag</span></span><br><span class="line">&#125;Tree[N];</span><br></pre></td></tr></table></figure></p>
<h2 id="建树操作"><a href="#建树操作" class="headerlink" title="建树操作"></a>建树操作</h2><p>我们使用递归操作来建树</p>
<blockquote>
<ul>
<li>当左端点和右段点相同时，意味着此时的$p$节点是叶子节点</li>
<li>二分当前区间，递归建树</li>
</ul>
</blockquote>
<p>注意，这里有两个尚未出现的东西，$pushup$函数和$lztag$标记</p>
<p>$pushup$函数用于从子节点向上依次更新父节点的值<br>而$lztag$是用于区间修改的懒标记</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(LL p,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lztag[p]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;Tree[p]=a[l];<span class="keyword">return</span> ;&#125;</span><br><span class="line">    LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    buildTree(getLeftNum(p),l,mid);</span><br><span class="line">    buildTree(getRightNum(p),mid+<span class="number">1</span>,r);</span><br><span class="line">    pushup(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pushup-操作"><a href="#pushup-操作" class="headerlink" title="pushup 操作"></a>pushup 操作</h2><p>$pushup$起到更新的作用，对于不同的需求，有不同的$pushup$操作</p>
<p>对于求和，可以这么写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree[p]=Tree[getLeftNum(p)]+Tree[getRightNum(p)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而对于求 最大值/最小值 ，则可以这么写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put_up</span><span class="params">(LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree[p]=max(Tree[getLeftNum(p)],Tree[getRightNum(p)]);</span><br><span class="line">    <span class="comment">//Tree[p]=min(Tree[getLeftNum(p)],Tree[getRightNum(p)]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h2><p>更新操作可以分为两种</p>
<ul>
<li>单点操作</li>
<li>区间操作</li>
</ul>
<h3 id="单点操作（updataPot）"><a href="#单点操作（updataPot）" class="headerlink" title="单点操作（updataPot）"></a>单点操作（updataPot）</h3><p>明确变量名：</p>
<ol>
<li>（l ~ r） ——  可支配区间</li>
<li>（nedChangeL ~ nedChangeR） ——  需操作区间</li>
<li>mid —— 可支配区间中点</li>
</ol>
<p>注 :</p>
<blockquote>
<ul>
<li>当$mid$不小于$nedChangeL$时 代表去 $l$ ~ $mid$ 更新是有意义的，所以，我们选择更新该区间</li>
<li>$mid$和$nedChangeR$同理</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updataPot</span><span class="params">(LL nedChangeL,LL nedChangeR,LL l,LL r,LL p,LL num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;Tree[p]=num;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nedChangeL&lt;=mid) updata(nedChangeL,nedChangeR,l,mid,getLeftNum(p),num);</span><br><span class="line">    <span class="keyword">if</span>(nedChangeR&gt;mid) updata(nedChangeL,nedChangeR,mid+<span class="number">1</span>,r,getRightNum(p),num);</span><br><span class="line">    put_up(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间操作（updataInterval）"><a href="#区间操作（updataInterval）" class="headerlink" title="区间操作（updataInterval）"></a>区间操作（updataInterval）</h3><p>#区间操作需要引入一个概念 </p>
<blockquote>
<p>$lazytag$ :<br>$lazytag$标注的是线段树中每个树的变化量，即 $\Delta$ </p>
<p>$lazytag$ 操作时正如其名，只对目前状态打上标记，等到更新时，才向下传递<br>因此，引入另一个函数$pushdown$，用于更新其子节点的$lazytag$和本节点的数值</p>
</blockquote>
<p>接下来给出$pushdown$的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">updataSum</span><span class="params">(LL p,LL l,LL r,LL num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lztag[p]=lztag[p]+num;</span><br><span class="line">    Tree[p]+=num*(r-l+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put_down</span><span class="params">(LL p,LL l,LL r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    updataSum(getLeftNum(p),l,mid,lztag[p]);</span><br><span class="line">    updataSum(getRightNum(p),mid+<span class="number">1</span>,r,lztag[p]);</span><br><span class="line">    lztag[p]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了$pushdown$算法，我们可以完成$updata$操作<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updataInterval</span><span class="params">(LL needChangeL,LL needChangeR,LL l,LL r,LL p,LL num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needChangeL&lt;=l&amp;&amp;r&lt;=needChangeR) &#123;updataSum(p,l,r,num);<span class="keyword">return</span> ;&#125;</span><br><span class="line">    put_down(p,l,r);</span><br><span class="line">    LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(needChangeL&lt;=mid) updata(needChangeL,needChangeR,l,mid,getLeftNum(p),num);</span><br><span class="line">    <span class="keyword">if</span>(needChangeR&gt;mid) updata(needChangeL,needChangeR,mid+<span class="number">1</span>,r,getRightNum(p),num);</span><br><span class="line">    put_up(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="区间求值（query）"><a href="#区间求值（query）" class="headerlink" title="区间求值（query）"></a>区间求值（query）</h2><p>区间求值时，我们进行了询问，而因为$lazytag$的原因，在求值之前，需先进行$pushdown$操作<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">getSum</span><span class="params">(LL qx,LL qy,LL l,LL r,LL p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(qx&lt;=l&amp;&amp;r&lt;=qy)<span class="keyword">return</span> Tree[p];</span><br><span class="line">    LL mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    put_down(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(qx&lt;=mid)sum+=getSum(qx,qy,l,mid,getLeftNum(p));</span><br><span class="line">    <span class="keyword">if</span>(qy&gt;mid) sum+=getSum(qx,qy,mid+<span class="number">1</span>,r,getRightNum(p));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1></div><div class="tags"><a href="/tags/数据结构/">数据结构</a><a href="/tags/模版/">模版</a><a href="/tags/普通线段树/">普通线段树</a></div><div class="post-nav"><a class="pre" href="/posts/30408/">Segment Tree(ZKW)(PART TWO)</a><a class="next" href="/posts/57313/">最小生成树</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'MOX1guFJ7jbu0OuGC8LVwOKb-gzGzoHsz',
  appKey:'xWx9J4xtQn3KSBcJoFShwElJ',
  placeholder:'Just so so',
  avatar:'mp',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/ZKW线段树/" style="font-size: 15px;">ZKW线段树</a> <a href="/tags/归档/" style="font-size: 15px;">归档</a> <a href="/tags/模版/" style="font-size: 15px;">模版</a> <a href="/tags/FHQ-Treap/" style="font-size: 15px;">FHQ Treap</a> <a href="/tags/普通线段树/" style="font-size: 15px;">普通线段树</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/stl/" style="font-size: 15px;">stl</a> <a href="/tags/数论/" style="font-size: 15px;">数论</a> <a href="/tags/题解/" style="font-size: 15px;">题解</a> <a href="/tags/分块/" style="font-size: 15px;">分块</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/1138517949/">树的直径-题解</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2952530072/">树上差分-题解</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/36423/">bitset讲解</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/15425/">数论</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/31323/">Balance Tree(FHQ Treap)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/20389/">莫队</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/30408/">Segment Tree(ZKW)(PART TWO)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7674/">Segment Tree (PART ONE)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/57313/">最小生成树</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/60366/">位运算</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://lin1043.tk" title="Lin1043" target="_blank">Lin1043</a><ul></ul><a href="http://waautomaton.tk" title="waautomaton" target="_blank">waautomaton</a><ul></ul><a href="http://xujikai.cc" title="ieqefcr" target="_blank">ieqefcr</a><ul></ul><a href="https://www.cnblogs.com/owencodeisking/" title="Owen_codeisking" target="_blank">Owen_codeisking</a><ul></ul><a href="https://yirannn.com/" title="JLOI - yirannn" target="_blank">JLOI - yirannn</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">ROY1994.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>